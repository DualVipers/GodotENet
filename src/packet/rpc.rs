use super::Packet;
use crate::variant::Variant;
use std::sync::Arc;

// From scene_rpc_interface.h
const NODE_ID_COMPRESSION_SHIFT: u8 = 4;
const NAME_ID_COMPRESSION_SHIFT: u8 = 6;
const BYTE_ONLY_OR_NO_ARGS_SHIFT: u8 = 7;

// From scene_rpc_interface.h
const NODE_ID_COMPRESSION_FLAG: u8 =
    (1 << NODE_ID_COMPRESSION_SHIFT) | (1 << (NODE_ID_COMPRESSION_SHIFT + 1));
const NAME_ID_COMPRESSION_FLAG: u8 = 1 << NAME_ID_COMPRESSION_SHIFT;
const BYTE_ONLY_OR_NO_ARGS_FLAG: u8 = 1 << BYTE_ONLY_OR_NO_ARGS_SHIFT;

#[derive(Clone)]
/// Parsed RPC Command
///
/// Generated by [`RPCParseLayer`](crate::layers::RPCParseLayer)
pub struct RPCCommand {
    pub path: String,

    pub args: Vec<Arc<Box<dyn Variant>>>,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RPCCommandHeader {
    pub node_id_compression: u8,
    pub node_id: u32,
    pub name_id_compression: u8,
    pub name_id: u32,

    pub byte_only_or_no_args: bool,
}

// Heavily Uses SceneRPCInterface::process_rpc() and SceneMultiplayer in Godot to revese engineer the header
pub fn parse_packet(packet: &[u8]) -> Result<Packet, String> {
    if packet.len() < 1 {
        return Err("Packet too short to contain Godot ENet header".to_string());
    }

    let node_id_compression = (packet[0] & NODE_ID_COMPRESSION_FLAG) >> NODE_ID_COMPRESSION_SHIFT;
    let name_id_compression = (packet[0] & NAME_ID_COMPRESSION_FLAG) >> NAME_ID_COMPRESSION_SHIFT;

    if packet.len() < 1 + (2 ^ node_id_compression as usize) + (2 ^ name_id_compression as usize) {
        return Err("Packet too short to contain Godot ENet header".to_string());
    }

    let node_id: u32 = match node_id_compression {
        0 => packet[1] as u32,
        1 => u16::from_le_bytes([packet[1], packet[2]]) as u32,
        2 => u32::from_le_bytes([packet[1], packet[2], packet[3], packet[4]]),
        _ => return Err("Invalid node_id_compression value".to_string()),
    };

    // Node *node = _process_get_node(p_from, p_packet, node_target, p_packet_len);
    // This is instead done in the RPCParseLayer, as it requires more data

    let offset: usize = 1 + (1 << node_id_compression) as usize;
    let name_id: u32 = match name_id_compression {
        0 => packet[offset] as u32,
        1 => u16::from_le_bytes([packet[offset], packet[1 + offset]]) as u32,
        _ => return Err("Invalid node_id_compression value".to_string()),
    };

    // From SceneRPCInterface::_process_rpc
    let byte_only_or_no_args = packet[0] & BYTE_ONLY_OR_NO_ARGS_FLAG != 0;

    Ok(Packet::NetworkCommandRemoteCall(RPCCommandHeader {
        node_id_compression,
        node_id,
        name_id_compression,
        name_id,

        byte_only_or_no_args,
    }))
}

// Reverse of parse_packet
pub fn gen_packet(
    packet: &RPCCommandHeader,
    args: Vec<Arc<Box<dyn Variant>>>,
) -> Result<Vec<u8>, String> {
    let mut out_packet: Vec<u8> = Vec::new();

    let mut header_byte: u8 = 0;
    if packet.byte_only_or_no_args {
        header_byte |= BYTE_ONLY_OR_NO_ARGS_FLAG;
    }
    header_byte |=
        (packet.node_id_compression << NODE_ID_COMPRESSION_SHIFT) & NODE_ID_COMPRESSION_FLAG;
    header_byte |=
        (packet.name_id_compression << NAME_ID_COMPRESSION_SHIFT) & NAME_ID_COMPRESSION_FLAG;

    out_packet.push(header_byte);

    match packet.node_id_compression {
        0 => {
            out_packet.push(packet.node_id as u8);
        }
        1 => {
            out_packet.extend_from_slice(&(packet.node_id as u16).to_le_bytes());
        }
        2 => {
            out_packet.extend_from_slice(&packet.node_id.to_le_bytes());
        }
        _ => panic!("Invalid node_id_compression value"),
    }

    match packet.name_id_compression {
        0 => {
            out_packet.push(packet.name_id as u8);
        }
        1 => {
            out_packet.extend_from_slice(&(packet.name_id as u16).to_le_bytes());
        }
        _ => panic!("Invalid name_id_compression value"),
    }

    // Inverse of crate::layers::RPCParseLayer

    if packet.byte_only_or_no_args {
        if args.len() == 1 {
            if let Some(pba) = args[0]
                .as_any()
                .downcast_ref::<crate::variant::PackedByteArray>()
            {
                out_packet.extend_from_slice(&pba.0);
            } else {
                return Err("RPC Command with byte_only_or_no_args set must have a single PackedByteArray argument".to_string());
            }
        } else if args.len() > 1 {
            return Err("RPC Command with byte_only_or_no_args set must have a single PackedByteArray argument".to_string());
        }
    } else {
        if args.len() > 255 {
            return Err("RPC Command cannot have more than 255 arguments".to_string());
        }
        out_packet.push(args.len() as u8);

        let mut i = 0;
        let count = args.len();
        for arg in args {
            // TODO: Include Compression?
            let mut encoded = arg.encode().map_err(|e| {
                format!(
                    "Failed to encode argument {} of {} in RPC Command: \n{}",
                    i + 1,
                    count,
                    e
                )
            })?;

            out_packet.append(&mut encoded);
            i += 1;
        }
    }

    Ok(out_packet)
}
