use super::Packet;
use crate::variant::Variant;
use std::sync::Arc;

// From scene_rpc_interface.h
const NODE_ID_COMPRESSION_SHIFT: u8 = 4;
const NAME_ID_COMPRESSION_SHIFT: u8 = 6;
const BYTE_ONLY_OR_NO_ARGS_SHIFT: u8 = 7;

// From scene_rpc_interface.h
const NODE_ID_COMPRESSION_FLAG: u8 =
    (1 << NODE_ID_COMPRESSION_SHIFT) | (1 << (NODE_ID_COMPRESSION_SHIFT + 1));
const NAME_ID_COMPRESSION_FLAG: u8 = 1 << NAME_ID_COMPRESSION_SHIFT;
const BYTE_ONLY_OR_NO_ARGS_FLAG: u8 = 1 << BYTE_ONLY_OR_NO_ARGS_SHIFT;

#[derive(Clone)]
/// Parsed RPC Command
///
/// Generated by [`RPCParseLayer`](crate::layers::RPCParseLayer)
pub struct RPCCommand {
    pub path: String,

    pub args: Vec<Arc<Box<dyn Variant>>>,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RPCCommandHeader {
    // TODO: Convert to holding the Command in an Option?
    pub node_id_compression: u8,
    pub node_id: u32,
    pub name_id_compression: u8,
    pub name_id: u32,

    pub byte_only_or_no_args: bool,
}

// Heavily Uses SceneRPCInterface::process_rpc() and SceneMultiplayer in Godot to revese engineer the header
pub fn parse_packet(packet: &[u8]) -> Result<Packet, String> {
    if packet.len() < 1 {
        return Err("Packet too short to contain Godot ENet header".to_string());
    }

    let node_id_compression = (packet[0] & NODE_ID_COMPRESSION_FLAG) >> NODE_ID_COMPRESSION_SHIFT;
    let name_id_compression = (packet[0] & NAME_ID_COMPRESSION_FLAG) >> NAME_ID_COMPRESSION_SHIFT;

    if packet.len() < 1 + (1 << node_id_compression) + (1 << name_id_compression) {
        return Err("Packet too short to contain Godot ENet RPC header".to_string());
    }

    let node_id: u32 = match node_id_compression {
        0 => packet[1] as u32,
        1 => u16::from_le_bytes([packet[1], packet[2]]) as u32,
        2 => u32::from_le_bytes([packet[1], packet[2], packet[3], packet[4]]),
        _ => return Err("Invalid node_id_compression value".to_string()),
    };

    // Node *node = _process_get_node(p_from, p_packet, node_target, p_packet_len);
    // This is instead done in the RPCParseLayer, as it requires more data

    let offset: usize = 1 + (1 << node_id_compression) as usize;
    let name_id: u32 = match name_id_compression {
        0 => packet[offset] as u32,
        1 => u16::from_le_bytes([packet[offset], packet[1 + offset]]) as u32,
        _ => return Err("Invalid name_id_compression value".to_string()),
    };

    // From SceneRPCInterface::_process_rpc
    let byte_only_or_no_args = packet[0] & BYTE_ONLY_OR_NO_ARGS_FLAG != 0;

    Ok(Packet::NetworkCommandRemoteCall(RPCCommandHeader {
        node_id_compression,
        node_id,
        name_id_compression,
        name_id,

        byte_only_or_no_args,
    }))
}

// Reverse of parse_packet
pub fn gen_packet(header: &RPCCommandHeader, command: &RPCCommand) -> Result<Vec<u8>, String> {
    let mut out_packet: Vec<u8> = Vec::new();

    let mut header_byte: u8 = 0;
    if header.byte_only_or_no_args {
        header_byte |= BYTE_ONLY_OR_NO_ARGS_FLAG;
    }
    header_byte |=
        (header.node_id_compression << NODE_ID_COMPRESSION_SHIFT) & NODE_ID_COMPRESSION_FLAG;
    header_byte |=
        (header.name_id_compression << NAME_ID_COMPRESSION_SHIFT) & NAME_ID_COMPRESSION_FLAG;

    out_packet.push(header_byte);

    match header.node_id_compression {
        0 => {
            out_packet.push(header.node_id as u8);
        }
        1 => {
            out_packet.extend_from_slice(&(header.node_id as u16).to_le_bytes());
        }
        2 => {
            out_packet.extend_from_slice(&header.node_id.to_le_bytes());
        }
        _ => panic!("Invalid node_id_compression value"),
    }

    match header.name_id_compression {
        0 => {
            out_packet.push(header.name_id as u8);
        }
        1 => {
            out_packet.extend_from_slice(&(header.name_id as u16).to_le_bytes());
        }
        _ => panic!("Invalid name_id_compression value"),
    }

    // Inverse of crate::layers::RPCParseLayer

    if header.byte_only_or_no_args {
        if command.args.len() == 1 {
            if let Some(pba) = command.args[0]
                .as_any()
                .downcast_ref::<crate::variant::PackedByteArray>()
            {
                out_packet.extend_from_slice(&pba.0);
            } else {
                return Err("RPC Command with byte_only_or_no_args set must have a single PackedByteArray argument".to_string());
            }
        } else if command.args.len() > 1 {
            return Err("RPC Command with byte_only_or_no_args set must have a single PackedByteArray argument".to_string());
        }
    } else {
        if command.args.len() > 255 {
            return Err("RPC Command cannot have more than 255 arguments".to_string());
        }
        out_packet.push(command.args.len() as u8);

        let mut i = 0;
        let count = command.args.len();
        for arg in &command.args {
            // TODO: Include Compression?
            let mut encoded = arg.encode().map_err(|e| {
                format!(
                    "Failed to encode argument {} of {} in RPC Command: \n{}",
                    i + 1,
                    count,
                    e
                )
            })?;

            out_packet.append(&mut encoded);
            i += 1;
        }
    }

    Ok(out_packet)
}

// Reverse of parse_packet
/// Does not use the packet's node_id and node_id_compression to allow encoding the given path
pub fn gen_packet_with_path(
    header: &RPCCommandHeader,
    command: &RPCCommand,
) -> Result<Vec<u8>, String> {
    let mut out_packet = gen_packet(
        &RPCCommandHeader {
            node_id: 0x80000000,
            node_id_compression: 2,

            ..*header
        },
        command,
    )?;

    let new_node_id_bytes = ((0x80000000 | out_packet.len()) as u32).to_le_bytes();

    out_packet[1] = new_node_id_bytes[0];
    out_packet[2] = new_node_id_bytes[1];
    out_packet[3] = new_node_id_bytes[2];
    out_packet[4] = new_node_id_bytes[3];

    out_packet.extend(command.path.as_bytes());
    out_packet.push(0); // Null terminator

    Ok(out_packet)
}
